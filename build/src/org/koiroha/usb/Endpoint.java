/* **************************************************************************
 * Copyright (C) 2009 koiroha.org All Right Reserved
 * **************************************************************************
 * This module, contains source code, binary and documentation, is in the
 * BSD License, and comes with NO WARRANTY.
 *
 *                                        takami torao <torao@mars.dti.ne.jp>
 *                                                     http://www.koiroha.org
 * $Id: Endpoint.java,v 1.13 2009/05/21 12:02:54 torao Exp $
*/
package org.koiroha.usb;

import java.util.List;

import org.koiroha.usb.desc.*;
import org.koiroha.usb.event.IsocTransferListener;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Endpoint: エンドポイント
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/**
 * エンドポイントを表すインターフェースです。エンドポイントはホストとデバイスが持つ FIFO パイプの
 * 端点です。双方のエンドポイントはパイプでつながっており、パイプは IN または OUT のどちらかの
 * 転送方向を持ちます。
 * <p>
 * エンドポイントへの入出力操作を行うにはインターフェースが要求されている必要があります。
 * <p>
 * @version usb4j 1.0 $Revision: 1.13 $ $Date: 2009/05/21 12:02:54 $
 * @author torao
 * @since 2009/04/23 Java2 SE 5.0
 */
public interface Endpoint {

	// ======================================================================
	// エンドポイント番号
	// ======================================================================
	/**
	 * このエンドポイントの番号 {@code bEndpointNumber} を参照します。
	 * <p>
	 * @return エンドポイント番号
	 */
	public int getEndpointNumber();

	// ======================================================================
	// エンドポイント記述子の参照
	// ======================================================================
	/**
	 * このエンドポイントの記述子を参照します。
	 * <p>
	 * @return エンドポイント記述子
	 */
	public EndpointDescriptor getDescriptor();

	// ======================================================================
	// 追加記述子の参照
	// ======================================================================
	/**
	 * このエンドポイントに設定されているクラス仕様/ベンダー仕様の記述子を参照します。
	 * <p>
	 * @return 追加の記述子
	 */
	public List<Descriptor> getAdditionalDescriptor();

	// ======================================================================
	// 代替設定の参照
	// ======================================================================
	/**
	 * このエンドポイントを持つ代替設定を参照します。
	 * <p>
	 * @return 代替設定
	 */
	public AltSetting getAltSetting();

	// ======================================================================
	// パイプのリセット
	// ======================================================================
	/**
	 * エンドポイントに設定されている halt 状態をクリアします。このメソッドはホスト側の状態のみ
	 * に作用します。デバイス側の halt 状態もクリアする場合は {@link ControlRequest#CLEAR_FEATURE}
	 * のデバイスリクエストを実行する必要があります。
	 * <p>
	 * @throws USBException 状態のクリアに失敗した場合
	 */
	public void clearHalt() throws USBException;

	// ======================================================================
	// 機能のクリア
	// ======================================================================
	/**
	 * このエンドポイントに対して CLEAR_FEATURE 要求を実行します。
	 * <p>
	 * @param feature 機能識別子
	 * @throws USBException コントロール要求に失敗した場合
	 */
	public void clearFeature(int feature) throws USBException;

	// ======================================================================
	// 機能の設定
	// ======================================================================
	/**
	 * このエンドポイントに対して SET_FEATURE 要求を実行します。
	 * <p>
	 * @param feature 機能識別子
	 * @throws USBException コントロール要求に失敗した場合
	 */
	public void setFeature(int feature) throws USBException;

	// ======================================================================
	// ステータスの取得
	// ======================================================================
	/**
	 * GET_STATUS 要求を実行してエンドポイントのステータスを取得します。返値は UINT16 の
	 * 範囲をとります。
	 * <p>
	 * @return ステータス
	 * @throws USBException コントロール要求に失敗した場合
	 */
	public int getStatus() throws USBException;

	// ======================================================================
	// フレームの同期
	// ======================================================================
	/**
	 * SYNCH_FRAME 要求を実行してエンドポイントのフレームを同期します。返値は UINT16 の範囲
	 * をとります。
	 * <p>
	 * @return フレームの同期データ
	 * @throws USBException コントロール要求に失敗した場合
	 */
	public int synchFrame() throws USBException;

	// ======================================================================
	// データの出力
	// ======================================================================
	/**
	 * {@link TransferType#BULK} または  {@link TransferType#INTERRUPT} のエンド
	 * ポイントに対して指定されたデータを送信します。エンドポイントがそれ以外の転送タイプであっ
	 * たり転送方向が {@link Direction#OUT} でない場合は例外が発生します。
	 * このメソッドはデバイスがオープンしインターフェースが要求済みの場合に実行する事が出来ます。
	 * <p>
	 * 書き込みタイムアウトをミリ秒で指定することができます。負の値を指定した場合、実装側で可能な
	 * 限りの待機を行います。
	 * <p>
	 * いくつかのデバイスでは 0 バイトデータの送信が意味を持つことがあるため、サブクラスは
	 * length が 0 の書き込みを省略しないよう実装する必要があります。
	 * <p>
	 * @param buffer 出力用のデータが格納されているバッファ
	 * @param offset バッファ内のデータのオフセット
	 * @param length バッファ内のデータの長さ
	 * @param timeout タイムアウト (ミリ秒)
	 * @throws USBException データの出力に失敗した場合
	 */
	public void write(byte[] buffer, int offset, int length, int timeout) throws USBException;

	// ======================================================================
	// データの入力
	// ======================================================================
	/**
	 * {@link TransferType#BULK} または {@link TransferType#INTERRUPT} のエンド
	 * ポイントから指定されたバッファにデータを受信します。エンドポイントがそれ以外のタイプで
	 * あったり転送方向が {@link Direction#IN} でない場合は例外が発生します。
	 * このメソッドはデバイスがオープンしインターフェースが要求済みの場合に実行する事が出来ます。
	 * <p>
	 * 読み込みタイムアウトをミリ秒で指定することができます。負の値を指定した場合、実装側で可能な
	 * 限りの待機を行います。
	 * <p>
	 * @param buffer 入力データを格納するバッファ
	 * @param offset バッファ内のデータのオフセット
	 * @param length バッファ内のデータの長さ
	 * @param timeout タイムアウト (ミリ秒)
	 * @return 実際に読み込んだ長さ
	 * @throws USBException データの入力に失敗した場合
	 */
	public int read(byte[] buffer, int offset, int length, int timeout) throws USBException;

	// ======================================================================
	// 等時間隔受信の開始
	// ======================================================================
	/**
	 * このエンドポイントでの等時間隔 (Isochronous) 受信を開始します。このメソッドは
	 * {@code startIsochronousRead(l, frames, Thread.NORM_PRIORITY)} と等価です。
	 * <p>
	 * @param l データ受信を通知するリスナ
	 * @param startFrame 開始フレーム
	 * @param frames リスナに通知するフレーム (ミリ秒) 単位
	 * @param bufSize 1フレーム当たりのバッファサイズ
	 * @throws USBException 等時間隔受信の開始に失敗した場合
	 */
	public void startIsocRead(IsocTransferListener l, long startFrame, int frames, int bufSize) throws USBException;

	// ======================================================================
	// 等時間隔受信の開始
	// ======================================================================
	/**
	 * このエンドポイントでの等時間隔 (Isochronous) 受信を開始します。このメソッドは受信用の
	 * スレッドを新規に起動し、{@link #stopIsocRead()} が呼び出されるまでパケット
	 * の受信をリスナに通知し続けます。
	 * <p>
	 * 配信スレッドの優先順位は {@link Thread} クラスに定義されている値の範囲で指定してくだ
	 * さい。
	 * <p>
	 * エンドポイントのパイプが {@link TransferType#ISOCHRONOUS} でない場合や、既に
	 * 等時間隔受信が開始されている場合は例外が発生します。
	 * <p>
	 * @param l データ受信を通知するリスナ
	 * @param startFrame 開始フレーム
	 * @param frames リスナに通知するフレーム (ミリ秒) 単位
	 * @param bufSize 1フレーム当たりのバッファサイズ
	 * @param priority イベント配信スレッドの優先順位
	 * @throws USBException 等時間隔受信の開始に失敗した場合
	 */
	public void startIsocRead(IsocTransferListener l, long startFrame, int frames, int bufSize, int priority) throws USBException;

	// ======================================================================
	// 等時間隔受信の終了
	// ======================================================================
	/**
	 * このエンドポイントで行っている等時間隔受信を停止します。等時間隔受信が行われていない場合は
	 * 何も行いません。
	 * <p>
	 * @throws USBException 等時間隔受信の停止に失敗した場合
	 */
	public void stopIsocRead() throws USBException;

}
