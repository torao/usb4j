/* **************************************************************************
 * Copyright (C) 2009 koiroha.org All Right Reserved
 * **************************************************************************
 * This module, contains source code, binary and documentation, is in the
 * BSD License, and comes with NO WARRANTY.
 *
 *                                        takami torao <torao@mars.dti.ne.jp>
 *                                                     http://www.koiroha.org
 * $Id: Device.java,v 1.10 2009/05/21 12:02:54 torao Exp $
*/
package org.koiroha.usb;

import java.io.Closeable;
import java.util.List;

import org.koiroha.usb.desc.DeviceDescriptor;
import org.koiroha.usb.event.DeviceListener;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Device: デバイスインターフェース
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/**
 * USB デバイスを表すインターフェースです。デバイス記述子とコンフィギュレーションを参照することが
 * 出来ます。
 * <p>
 * @version usb4j 1.0 $Revision: 1.10 $ $Date: 2009/05/21 12:02:54 $
 * @author torao
 * @since 2009/04/23 Java2 SE 5.0
 */
public interface Device extends Closeable{

	// ======================================================================
	// デバイス記述の参照
	// ======================================================================
	/**
	 * このデバイスの記述子を参照します。
	 * <p>
	 * @return デバイス記述子
	 */
	public DeviceDescriptor getDescriptor();

	// ======================================================================
	// バスの参照
	// ======================================================================
	/**
	 * このデバイスが接続されているバス情報を参照します。
	 * <p>
	 * @return このデバイスのバス
	 */
	public Bus getBus();

	// ======================================================================
	// 親デバイスの参照
	// ======================================================================
	/**
	 * このデバイスが接続されているデバイス (ハブなど) を参照します。デバイスがバスのルートハブ
	 * を示す場合は null を返します。
	 * <p>
	 * この機能はオプションです。サポートしていない実装では実際のトポロジー構造を無視して全ての
	 * デバイスで null を返します。
	 * <p>
	 * @return このデバイスの親デバイス
	 */
	public Device getParentDevice();

	// ======================================================================
	// 子デバイスの参照
	// ======================================================================
	/**
	 * このデバイスに接続されている別のデバイスを参照します。子のデバイスを持たない場合は長さ 0
	 * のリストを返します。
	 * <p>
	 * この機能はオプションです。サポートしていない実装では実際のトポロジー構造を無視して全ての
	 * デバイスで長さ 0 のリストを返します。
	 * <p>
	 * @return このデバイスの子デバイス
	 */
	public List<Device> getChildDevices();

	// ======================================================================
	// コンフィギュレーション一覧の参照
	// ======================================================================
	/**
	 * このデバイスのコンフィギュレーション一覧を取得します。
	 * このメソッドの実行にデバイスがオープンされている必要はありません。
	 * <p>
	 * デバイスに対して別の処理が排他的アクセス権を持っている場合、ネイティブ実装がコンフィギュ
	 * レーション情報を取得できない可能性があります。このため、このメソッドはデバイス記述子の
	 * {@link DeviceDescriptor#getNumConfigurations() bNumConfigurations} よりも
	 * 小さな個数のコンフィギュレーションを返す可能性がある事に注意してください。
	 * <p>
	 * @return このデバイスのコンフィギュレーションリスト
	 */
	public List<Configuration> getConfigurations();

	// ======================================================================
	// デバイスオープンの判定
	// ======================================================================
	/**
	 * このデバイスがオープンされているかどうかを確認します。
	 * <p>
	 * @return オープンされている場合 true
	 */
	public boolean isOpen();

	// ======================================================================
	// デバイスのオープン
	// ======================================================================
	/**
	 * このデバイスをオープンしてアプリケーションからの操作が可能な状態にします。アプリケーション
	 * はオープンしたデバイスの {@link #close()} を呼び出してオープン状態を終了する必要が
	 * あります。
	 * <p>
	 * このインスタンスがオープンされている場合や既に解放されている場合は例外が発生します。
	 * <p>
	 * @throws USBException デバイスのオープンに失敗した場合
	 */
	public void open() throws USBException;

	// ======================================================================
	// デバイスのクローズ
	// ======================================================================
	/**
	 * このデバイスをクローズしてアプリケーションからの操作を終了します。デバイスがオープンされて
	 * いない場合や既に解放されている場合は何も行われません。一度クローズしたデバイスを再度オー
	 * プンして利用することが出来ます。
	 * <p>
	 * @throws USBException デバイスのクローズに失敗した場合
	 */
	public void close() throws USBException;

	// ======================================================================
	// デバイスのリセット
	// ======================================================================
	/**
	 * このデバイスの通信状態をリセットし開放状態にします。再度デバイスを利用するには再取得を行う
	 * 必要があります。
	 * <p>
	 * このメソッドの呼び出しにはデバイスがオープンされている必要があります。
	 * <p>
	 * @throws USBException リセットに失敗した場合
	 */
	public void reset() throws USBException;

	// ======================================================================
	// 機能のクリア
	// ======================================================================
	/**
	 * このデバイスに対して CLEAR_FEATURE 要求を実行します。
	 * <p>
	 * @param feature 機能識別子
	 * @throws USBException コントロール要求に失敗した場合
	 */
	public void clearFeature(int feature) throws USBException;

	// ======================================================================
	// 機能の設定
	// ======================================================================
	/**
	 * このデバイスに対して SET_FEATURE 要求を実行します。
	 * <p>
	 * @param feature 機能識別子
	 * @throws USBException コントロール要求に失敗した場合
	 */
	public void setFeature(int feature) throws USBException;

	// ======================================================================
	// ステータスの取得
	// ======================================================================
	/**
	 * GET_STATUS 要求を実行してデバイスのステータスを取得します。返値は UINT16 の範囲を
	 * とります。
	 * <p>
	 * @return ステータス
	 * @throws USBException コントロール要求に失敗した場合
	 */
	public int getStatus() throws USBException;

	// ======================================================================
	// アクティブコンフィギュレーションの設定
	// ======================================================================
	/**
	 * デバイスに対する操作の対象となるコンフィギュレーションを設定します。{@code conf} には
	 * 対応するコンフィギュレーション記述子の {@code bConfigurationValue} 値を指定します
	 * (一般的にこの値は 1 から始まります)。無効なコンフィギュレーションが指定された場合は例外
	 * が発生します。
	 * <p>
	 * このメソッドの呼び出しにはデバイスがオープンされている必要があります。
	 * <p>
	 * @param conf アクティブにするコンフィギュレーション
	 * @throws USBException コンフィギュレーションの設定に失敗した場合
	 */
	public void setActiveConfiguration(int conf) throws USBException;

	// ======================================================================
	// アクティブコンフィギュレーションの参照
	// ======================================================================
	/**
	 * デバイスに対する操作の対象となるコンフィギュレーションを参照します。このメソッドは {@code
	 * getActiveConfiguration(false)} と等価です。
	 * <p>
	 * @return アクティブにするコンフィギュレーション
	 * @throws USBException コンフィギュレーションの取得に失敗した場合
	 */
	public int getActiveConfiguration() throws USBException;

	// ======================================================================
	// アクティブコンフィギュレーションの参照
	// ======================================================================
	/**
	 * デバイスに対する操作の対象となるコンフィギュレーションを参照します。返値は対応するコンフィ
	 * ギュレーション記述子の {@code bConfigurationValue} 値です。
	 * <p>
	 * {@code forceRetrieve} パラメータに true を指定した場合、デバイスのインスタンスが
	 * 保持している現在のコンフィギュレーション値を無視してデバイスに GET_CONFIGURATION 要求
	 * を発行します。false を指定した場合、インスタンスが既知のコンフィギュレーション値を保持し
	 * ていればそれが返されます。ただしコンフィギュレーション値が未定の場合はデバイスに
	 * GET_CONFIGURATION 要求を発行します。
	 * <p>
	 * このメソッドの呼び出しにはデバイスがオープンされている必要があります。
	 * <p>
	 * @param forceRetrieve GET_CONFIGURATION 要求を発行する場合 true
	 * @return アクティブにするコンフィギュレーション
	 * @throws USBException コンフィギュレーションの取得に失敗した場合
	 */
	public int getActiveConfiguration(boolean forceRetrieve) throws USBException;

	// ======================================================================
	// デバイスハンドルの参照
	// ======================================================================
	/**
	 * このデバイスのハンドルを参照します。返値の意味はプラットフォームごとのネイティブ実装および
	 * usb4j のポーティング実装に依存しています。このメソッドはアプリケーションに対して問題分析
	 * のトレースの目的でのみ公開されています。サブクラスは返値の toStirng() でハンドルを識別
	 * できる情報を返す必要があります。
	 * <p>
	 * リソースがオープンされていない場合や既に解放されている場合、このメソッドは null を返します。
	 * <p>
	 * @return このリソースのハンドル値
	 */
	// public Object getHandle();

	// ======================================================================
	// 文字列記述子の参照
	// ======================================================================
	/**
	 * 指定された文字列記述子 (String Descriptor) の {@code bString} を参照します。
	 * このメソッドの呼び出しにはデバイスがオープンされている必要があります。インデックスに対応
	 * する文字列記述子が定義されていない場合は FIXME <i>仕様未決</i>
	 * <p>
	 * このメソッドはインデックスに 0 を指定した {@code wLANGID} 取得には対応していません。
	 * デバイスの言語 ID を参照する場合は明示的に {@link #getLangID()} を使用してください。
	 * これは各記述子における文字列記述子インデックスの無効値が 0 であることから、アプリケー
	 * ションが意図せず言語 ID を文字列として扱うことを避けるためです。
	 * <p>
	 * インデックスや文字列記述子に範囲外の値を指定した場合は例外が発生します。
	 * <p>
	 * @param index 文字列記述子のインデックス (1-255)
	 * @param langid 言語 ID (0-65535)
	 * @return 文字列記述子の文字列
	 * @throws USBException 文字列記述子の取得に失敗した場合
	 * @see LangID 定義済みの言語 ID
	 */
	public String getString(int index, int langid) throws USBException;

	// ======================================================================
	// デフォルト言語 ID の参照
	// ======================================================================
	/**
	 * このデバイスの文字列記述子取得で使用できる言語 ID を問い合わせます。返値の配列に格納され
	 * ている言語 ID の順序はデバイス依存です。
	 * <p>
	 * このメソッドの呼び出しにはデバイスがオープンされている必要があります。
	 * <p>
	 * @return デフォルトの言語 ID
	 * @throws USBException 言語 ID の取得に失敗した場合
	 */
	public int[] getLangID() throws USBException;

	// ======================================================================
	// コントロール要求の実行
	// ======================================================================
	/**
	 * このインターフェースの指定されたエンドポイントに対してデバイス要求を実行します。
	 * このメソッドの実行にはデバイスが FIXME オープンされている必要がある?
	 * <p>
	 * @param request デバイスリクエスト
	 * @return 実際の入出力サイズ
	 * @throws USBException 言語 ID の取得に失敗した場合
	 */
	public int deviceRequest(ControlRequest request) throws USBException;

	// ======================================================================
	// デバイスリスナの追加
	// ======================================================================
	/**
	 * このデバイスにリスナを追加します。
	 * <p>
	 * @param l デバイスリスナ
	 */
	public void addDeviceListener(DeviceListener l);

	// ======================================================================
	// デバイスリスナの削除
	// ======================================================================
	/**
	 * このデバイスからリスナを削除します。該当するリスナが登録されていない場合は何も行いません。
	 * <p>
	 * @param l デバイスリスナ
	 */
	public void removeDeviceListener(DeviceListener l);

}
